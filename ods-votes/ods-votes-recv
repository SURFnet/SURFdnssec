#!/usr/bin/python
#
# ods-votes-recv -- Receive votes from local and remote Singer machines
#
# This program receives instructions ADDKEY and DELKEY with a zone as its
# argument, and processes it locally.  The instruction may have been sent
# from a local or remote process that interacts with PKCS #11.
#
# For ADDKEY, the proper response is to trigger updating the .signconf
# file for the zone.
#
# For DELKEY, the proper response is to remove the key from PKCS #11.
#
# From: Rick van Rein <rick@openfortress.nl>


import os
import sys
import time
import socket
import ssl

import pika

import rabbitdnssec
from rabbitdnssec import log_debug, log_info, log_notice, log_warning, log_error, log_critical


queuename = rabbitdnssec.my_queue ('signconf_votes')

backend = rabbitdnssec.my_backend ()


import os


def process_msg (chan, mth, props, body):
	ok = True
	try:
		[add_del, zone] = body.split (' ')
		if add_del == 'ADDKEY':
			# Key has already been added, no work to do here;
			# OpenDNSSEC update to .signconf follows below
			pass
		elif add_del == 'DELKEY':
			os.system ('ods-votes-' + backend + '-delkey ' + zone)
		else:
			log_error ('Invalid instruction', add_del, 'over signconf_votes')
			ok = False
		if backend == 'opendnssec':
			# Update .signconf, creating or deleting as per zonelist.xml
			os.system ('./ods-zonedata-signconf ' + zone)
	except Exception, e:
		log_error ('Exception:', e, 'for zone', zone)
		ok = False
	if not ok:
		log_error ('Failure while processing zonedata for ' + zone)
		chan.basic_nack (delivery_tag=mth.delivery_tag, requeue=False)
		chan.tx_rollback ()
	else:
		log_error ('Successfully processed zonedata update for ' + zone)
		chan.basic_ack  (delivery_tag=mth.delivery_tag)
		chan.tx_commit ()
		#TODO# signal parent/child system about updated zonedata

creds   = rabbitdnssec.my_credentials (ovr_username='confsigner')
cnxparm = rabbitdnssec.my_connectionparameters (creds)
props   = rabbitdnssec.my_basicproperties (ovr_username='pkcs11update')

cnx = None
chan = None
try:
	cnx = pika.BlockingConnection (cnxparm)
	chan = cnx.channel ()
	chan.basic_consume (process_msg, queue=queuename)
	chan.tx_select ()
	chan.start_consuming ()
except pika.exceptions.AMQPChannelError, e:
	log_error ('AMQP Channel Error:', e)
	sys.exit (1)
except pika.exceptions.AMQPError, e:
	log_error ('AMQP Error:', e)
	sys.exit (1)
finally:
	if chan is not None:
		chan.tx_rollback ()
		chan = None
	if cnx is not None:
		cnx.close ()
	cnx = None

sys.exit (0)
